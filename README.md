# 광고 관리 서비스

## 소개
이 프로젝트는 "매일모으기" 서비스를 위한 광고 관리 시스템입니다.  
이 시스템은 광고 등록, 조회, 참여, 이력 관리를 지원하며, 고성능 처리와 동시성 문제를 해결하기 위한 설계를 포함합니다.  
사용자에게 매력적인 광고를 제공하고, 광고주에게는 효과적인 광고 집행을 가능하게 하는 것을 목표로 합니다.

## 프로젝트 설계 (평가항목 반영)

### 1. 프로젝트 구성 방법 및 시스템 아키텍처 설계

#### 구성 요소
- **컨트롤러**: RESTful API를 제공하여 클라이언트와의 통신을 담당합니다. 각 API는 HTTP 요청을 처리하고, 적절한 응답을 반환합니다.
- **서비스**: 비즈니스 로직을 처리하는 계층으로, 광고 등록, 조회, 참여 등의 기능을 구현합니다. 이 계층은 데이터베이스와의 상호작용을 포함합니다.
- **저장소**: MySQL과 Redis를 통해 데이터 저장 및 캐싱을 수행합니다. MySQL은 영속적인 데이터 저장을 담당하고, Redis는 빠른 데이터 조회를 위한 캐시 역할을 합니다.


#### 고성능 설계
- **캐싱**: Redis를 활용하여 광고 데이터 조회를 최적화합니다. 자주 조회되는 데이터는 Redis에 캐시하여 데이터베이스의 부하를 줄입니다.
- **동시성 처리**: Redis의 분산 락을 활용하여 다량의 트래픽에서도 데이터 무결성을 보장합니다. 이를 통해 여러 사용자가 동시에 광고에 참여할 때 발생할 수 있는 경합 상태를 방지합니다.

### 2. 요구사항 구현

#### 주요 요구사항
- **광고 등록 API**:
    - 광고명, 적립 포인트, 노출 기간 등의 정보를 입력받아 광고를 등록합니다.
    - 중복된 광고명을 방지하는 로직을 포함하여, 동일한 광고명이 등록되지 않도록 합니다.

- **광고 조회 API**:
    - 현재 참여 가능한 광고만 반환합니다.
    - 적립 포인트 순으로 정렬하여 최대 10개의 광고를 반환합니다. 이를 통해 사용자는 가장 유리한 광고를 쉽게 찾을 수 있습니다.

- **광고 참여 API**:
    - 사용자의 참여 기록을 저장하고, 남은 참여 횟수를 차감합니다.
    - Redis의 분산 락을 사용하여 동시성 문제를 해결합니다. 이를 통해 여러 사용자가 동시에 참여 요청을 하더라도 데이터의 일관성을 유지합니다.

- **참여 이력 조회 API**:
    - 사용자별 참여 기록을 조회할 수 있습니다.
    - 기간별 필터링 및 페이지네이션을 지원하여, 사용자가 원하는 정보를 쉽게 찾을 수 있도록 합니다.

### 3. 코드 가독성과 의도

#### 컨벤션 준수
- 클래스와 메서드의 역할을 명확히 구분하여 코드의 가독성을 높입니다.
- Java Naming Convention 및 Clean Code 원칙을 준수하여, 유지보수성과 확장성을 고려한 코드를 작성합니다.

#### Swagger 활용
- `Swagger (SpringDoc OpenAPI)`를 사용하여 기술 명세서를 자동 생성합니다. 이를 통해 개발, QA, 협업 간 API 명세를 쉽게 공유할 수 있습니다.
- Swagger UI를 통해 직관적이고 명확한 API 문서화를 지원하여, 개발자와 비개발자 모두가 이해하기 쉽게 합니다.

### 4. 테스트 코드

#### 테스트 시나리오
- **유닛 테스트**:
    - 서비스 및 컨트롤러 레벨에서 비즈니스 로직을 검증합니다. 각 기능이 예상대로 작동하는지 확인합니다.
    - Gradle을 사용하여 테스트를 실행합니다:
      ```bash
      ./gradlew test
      ```

- **통합 테스트**:
    - H2 데이터베이스 및 Mock 객체를 활용하여 통합 테스트를 수행합니다. 광고 등록, 조회, 참여 흐름 전체를 테스트하여 시스템의 일관성을 검증합니다.

- **동시성 테스트**:
    - `CompletableFuture`를 활용하여 다량의 요청을 처리합니다. 100명의 사용자가 동시에 광고 등록 및 참여 요청을 시뮬레이션하여 시스템의 성능을 평가합니다.

#### 동시성 테스트 코드 예시:
```java
int concurrentUsers = 100;
CompletableFuture<Void>[] futures = new CompletableFuture[concurrentUsers];

IntStream.range(0, concurrentUsers).forEach(i -> {
    futures[i] = CompletableFuture.supplyAsync(() -> advertisementController.createAdvertisement(createRequest))
         .thenCompose(response -> CompletableFuture.supplyAsync(() -> participationController.participateInAdvertisement(participationRequest)))
         .thenRun(() -> successfulRequests.incrementAndGet()); 
});

CompletableFuture.allOf(futures).join();
```

## JMeter 부하 테스트
부하 테스트의 목적은 다량의 트래픽에서 시스템 성능을 검증하는 것입니다.  
테스트 대상 API는 다음과 같습니다:
- 광고 등록 API
- 광고 조회 API
- 광고 참여 API
- 참여 이력 조회 API

## 5. 효율적인 트래픽 처리

### 캐싱 및 최적화
- 광고 데이터는 Redis에 캐싱하여 반복 조회 시 성능을 최적화합니다.  
  이를 통해 데이터베이스의 부하를 줄이고, 응답 속도를 향상시킵니다.
- Redis의 TTL (Time to Live)을 활용하여 유효기간 만료 처리를 자동으로 수행합니다.  
  이를 통해 캐시된 데이터가 일정 시간이 지나면 자동으로 삭제되어, 항상 최신의 데이터를 유지할 수 있습니다.

### 분산 락
- Redis의 분산 락을 사용하여 데이터 경합 문제를 해결합니다.  
  이를 통해 남은 참여 횟수가 정확히 업데이트되도록 구현합니다.  
  분산 락을 통해 여러 사용자가 동시에 참여 요청을 하더라도 데이터의 일관성을 보장합니다.

### 확장성 고려
- API 서버는 수평 확장을 지원하도록 설계하여, 트래픽 급증 시에도 안정적으로 동작할 수 있도록 합니다.  
  이를 통해 사용자가 증가하더라도 시스템의 성능 저하 없이 서비스를 제공할 수 있습니다.
- Docker 및 Kubernetes 배포 환경을 통해 서비스의 확장성을 보장합니다.  
  이러한 환경을 통해 컨테이너화된 애플리케이션을 쉽게 배포하고 관리할 수 있습니다.

## 기술 스택
- **백엔드**: Java 17, Spring Boot 3.1.0
- **데이터베이스**: MySQL, H2 (테스트)
- **캐시**: Redis
- **문서화**: Swagger UI (SpringDoc OpenAPI)
- **빌드 도구**: Gradle

## 실행 및 테스트 방법

### Docker로 MySQL 및 Redis 실행
```bash
docker-compose up -d
```

### 애플리케이션 실행
```bash
./gradlew bootRun
```

### Swagger UI 확인

- Swagger UI를 통해 API 문서를 확인할 수 있습니다:
- http://localhost:8080/swagger-ui/index.html

### Gradle로 테스트 실행
```bash
./gradlew test
```

